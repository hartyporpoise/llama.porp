"""
TLS certificate generation and management for porpulsion agents.

Each agent auto-generates a private CA on first boot, persisted to the
porpulsion-credentials Kubernetes Secret. During peering the CA cert is
exchanged — peers store each other's CA and use it as the trust anchor
for the WebSocket channel (authenticated by CA fingerprint). This gives
full mutual authentication with no external dependencies.
"""
import base64
import os
import datetime
import ipaddress
from cryptography import x509
from cryptography.x509.oid import NameOID, ExtendedKeyUsageOID
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec


def generate_ca_and_leaf_cert(agent_name: str,
                               self_ip: str = "") -> tuple[bytes, bytes, bytes, bytes]:
    """
    Generate a private CA and a leaf cert signed by it.

    The CA cert is long-lived (10 years) and is what peers exchange during
    the peering handshake. The leaf cert is used on the mTLS listener and
    can be rotated independently without re-peering.

    self_ip: included as an IP SAN in the leaf cert so peers connecting
    by bare IP pass TLS hostname verification.

    Returns (ca_cert_pem, ca_key_pem, leaf_cert_pem, leaf_key_pem) as bytes.
    """
    # ── CA key + self-signed CA cert ──────────────────────────
    ca_key = ec.generate_private_key(ec.SECP256R1())  # ECDSA P-256
    ca_name = x509.Name([
        x509.NameAttribute(NameOID.COMMON_NAME, f"{agent_name}-ca"),
        x509.NameAttribute(NameOID.ORGANIZATION_NAME, "porpulsion"),
    ])
    ca_cert = (
        x509.CertificateBuilder()
        .subject_name(ca_name)
        .issuer_name(ca_name)
        .public_key(ca_key.public_key())
        .serial_number(x509.random_serial_number())
        .not_valid_before(datetime.datetime.now(datetime.timezone.utc))
        .not_valid_after(
            datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=3650)
        )
        .add_extension(x509.BasicConstraints(ca=True, path_length=0), critical=True)
        .add_extension(x509.KeyUsage(
            digital_signature=True, key_cert_sign=True, crl_sign=True,
            content_commitment=False, key_encipherment=False, data_encipherment=False,
            key_agreement=False, encipher_only=False, decipher_only=False,
        ), critical=True)
        .sign(ca_key, hashes.SHA256())
    )

    # ── Leaf key + cert signed by the CA ──────────────────────
    leaf_key = ec.generate_private_key(ec.SECP256R1())  # ECDSA P-256
    leaf_name = x509.Name([
        x509.NameAttribute(NameOID.COMMON_NAME, agent_name),
        x509.NameAttribute(NameOID.ORGANIZATION_NAME, "porpulsion"),
    ])
    san_entries: list = [x509.DNSName(agent_name)]
    if self_ip:
        try:
            san_entries.append(x509.IPAddress(ipaddress.ip_address(self_ip)))
        except ValueError:
            pass
    leaf_cert = (
        x509.CertificateBuilder()
        .subject_name(leaf_name)
        .issuer_name(ca_name)
        .public_key(leaf_key.public_key())
        .serial_number(x509.random_serial_number())
        .not_valid_before(datetime.datetime.now(datetime.timezone.utc))
        .not_valid_after(
            datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=365)
        )
        .add_extension(x509.BasicConstraints(ca=False, path_length=None), critical=True)
        .add_extension(x509.SubjectAlternativeName(san_entries), critical=False)
        .add_extension(x509.ExtendedKeyUsage([
            ExtendedKeyUsageOID.SERVER_AUTH,
            ExtendedKeyUsageOID.CLIENT_AUTH,
        ]), critical=False)
        .sign(ca_key, hashes.SHA256())
    )

    def _pem(obj):
        return obj.public_bytes(serialization.Encoding.PEM)

    def _key_pem(k):
        return k.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.NoEncryption(),
        )

    return _pem(ca_cert), _key_pem(ca_key), _pem(leaf_cert), _key_pem(leaf_key)


def write_temp_pem(pem_bytes: bytes, name: str) -> str:
    """Write PEM bytes to /tmp/porpulsion-{name}.pem and return the path."""
    path = f"/tmp/porpulsion-{name}.pem"
    with open(path, "wb") as f:
        f.write(pem_bytes)
    os.chmod(path, 0o600)
    return path


def cert_fingerprint(cert_pem: str | bytes) -> str:
    """Return the SHA-256 hex fingerprint of a PEM-encoded certificate."""
    if isinstance(cert_pem, str):
        cert_pem = cert_pem.encode()
    from cryptography.x509 import load_pem_x509_certificate
    cert = load_pem_x509_certificate(cert_pem)
    return cert.fingerprint(hashes.SHA256()).hex()


_CREDENTIALS_SECRET = "porpulsion-credentials"


def _k8s_core_v1():
    """Return a CoreV1Api client, loading config lazily."""
    from kubernetes import client, config as kube_config
    try:
        kube_config.load_incluster_config()
    except Exception:
        kube_config.load_kube_config()
    return client.CoreV1Api()


def _save_credentials_secret(core_v1, namespace: str,
                              ca_cert_pem: bytes | None = None,
                              ca_key_pem: bytes | None = None,
                              cert_pem: bytes | None = None,
                              key_pem: bytes | None = None,
                              invite_token: str | None = None,
                              self_ip: str | None = None,
                              peers_json: str | None = None) -> None:
    """
    Create or patch the porpulsion-credentials Secret with any non-None fields.
    """
    from kubernetes import client as k8s_client
    data = {}
    if ca_cert_pem is not None:
        data["ca.crt"] = base64.b64encode(ca_cert_pem).decode()
    if ca_key_pem is not None:
        data["ca.key"] = base64.b64encode(ca_key_pem).decode()
    if cert_pem is not None:
        data["tls.crt"] = base64.b64encode(cert_pem).decode()
    if key_pem is not None:
        data["tls.key"] = base64.b64encode(key_pem).decode()
    if invite_token is not None:
        data["invite-token"] = base64.b64encode(invite_token.encode()).decode()
    if self_ip is not None:
        data["self-ip"] = base64.b64encode(self_ip.encode()).decode()
    if peers_json is not None:
        data["peers"] = base64.b64encode(peers_json.encode()).decode()

    if not data:
        return

    secret = k8s_client.V1Secret(
        metadata=k8s_client.V1ObjectMeta(name=_CREDENTIALS_SECRET, namespace=namespace),
        data=data,
    )
    try:
        core_v1.create_namespaced_secret(namespace, secret)
    except k8s_client.ApiException as e:
        if e.status == 409:
            core_v1.patch_namespaced_secret(_CREDENTIALS_SECRET, namespace, secret)
        else:
            raise



def load_or_generate_ca(agent_name: str, namespace: str) -> tuple[bytes, bytes]:
    """
    Load the agent's CA cert + key from the porpulsion-credentials Secret, or
    generate them fresh if absent.  Returns (ca_cert_pem, ca_key_pem) as bytes.

    The CA cert is what peers exchange during peering and is used to authenticate
    the persistent WebSocket channel. The private key never leaves this agent.
    """
    import logging
    _log = logging.getLogger("porpulsion.tls")
    core_v1 = _k8s_core_v1()

    try:
        secret = core_v1.read_namespaced_secret(_CREDENTIALS_SECRET, namespace)
        d = secret.data or {}
        if "ca.crt" in d and "ca.key" in d:
            ca_cert_pem = base64.b64decode(d["ca.crt"])
            ca_key_pem  = base64.b64decode(d["ca.key"])
            _log.info("Loaded existing CA cert from Secret")
            return ca_cert_pem, ca_key_pem
    except Exception:
        pass  # Secret missing — generate fresh

    _log.info("Generating new CA for %s", agent_name)
    ca_cert_pem, ca_key_pem, _, _ = generate_ca_and_leaf_cert(agent_name)
    try:
        _save_credentials_secret(core_v1, namespace,
                                  ca_cert_pem=ca_cert_pem, ca_key_pem=ca_key_pem)
    except Exception as exc:
        _log.warning("Could not persist CA to Secret: %s", exc)
    return ca_cert_pem, ca_key_pem


def load_or_generate_token(namespace: str) -> str:
    """
    Try to load the invite token from the porpulsion-credentials Secret.
    If absent, generate a fresh one and save it back.
    """
    import logging
    import secrets as _secrets
    core_v1 = _k8s_core_v1()
    try:
        secret = core_v1.read_namespaced_secret(_CREDENTIALS_SECRET, namespace)
        if secret.data and "invite-token" in secret.data:
            token = base64.b64decode(secret.data["invite-token"]).decode()
            if token:
                return token
    except Exception:
        pass

    token = _secrets.token_hex(32)
    try:
        _save_credentials_secret(core_v1, namespace, invite_token=token)
    except Exception as exc:
        logging.getLogger("porpulsion.tls").warning(
            "Could not persist invite token to Secret: %s", exc
        )
    return token


def persist_token(namespace: str, token: str) -> None:
    """Write a rotated invite token back to the credentials Secret (fire-and-forget)."""
    import threading
    def _write():
        try:
            core_v1 = _k8s_core_v1()
            _save_credentials_secret(core_v1, namespace, invite_token=token)
        except Exception as exc:
            import logging
            logging.getLogger("porpulsion.tls").warning(
                "Could not persist rotated token to Secret: %s", exc
            )
    threading.Thread(target=_write, daemon=True).start()


# ── Peer persistence ──────────────────────────────────────────

def save_peers(namespace: str, peers: dict) -> None:
    """
    Persist the peers dict to the porpulsion-credentials Secret (fire-and-forget thread).
    Serialises each peer as {name, url, ca_pem}.
    """
    import json
    import threading
    import logging
    _log = logging.getLogger("porpulsion.tls")

    peer_list = [
        {"name": p.name, "url": p.url, "ca_pem": p.ca_pem}
        for p in peers.values()
    ]
    json_str = json.dumps(peer_list)

    def _write():
        try:
            core_v1 = _k8s_core_v1()
            _save_credentials_secret(core_v1, namespace, peers_json=json_str)
            _log.debug("Persisted %d peer(s) to Secret", len(peer_list))
        except Exception as exc:
            _log.warning("Could not persist peers to Secret: %s", exc)

    threading.Thread(target=_write, daemon=True).start()


def load_peers(namespace: str) -> list[dict]:
    """
    Load the peers list from the porpulsion-credentials Secret.
    Also re-writes each peer's CA PEM to /tmp so mTLS verify paths are ready.
    Returns [] on missing Secret or any error.
    """
    import json
    import logging
    _log = logging.getLogger("porpulsion.tls")
    try:
        core_v1 = _k8s_core_v1()
        secret = core_v1.read_namespaced_secret(_CREDENTIALS_SECRET, namespace)
        if not (secret.data and "peers" in secret.data):
            return []
        peer_list = json.loads(base64.b64decode(secret.data["peers"]).decode())
        for p in peer_list:
            if p.get("ca_pem"):
                write_temp_pem(
                    p["ca_pem"].encode() if isinstance(p["ca_pem"], str) else p["ca_pem"],
                    f"peer-ca-{p['name']}",
                )
        _log.info("Loaded %d peer(s) from Secret", len(peer_list))
        return peer_list
    except Exception as exc:
        _log.warning("Could not load peers from Secret: %s", exc)
        return []


# ── State ConfigMap (local_apps + settings) ───────────────────

_STATE_CONFIGMAP = "porpulsion-state"


def save_state_configmap(namespace: str, local_apps: dict, settings,
                         pending_approval: dict | None = None) -> None:
    """
    Persist local_apps, pending_approval, and settings to the porpulsion-state ConfigMap
    (fire-and-forget thread).
    """
    import json
    import threading
    import logging
    from kubernetes import client as k8s_client
    _log = logging.getLogger("porpulsion.tls")

    apps_json     = json.dumps([a.to_dict() for a in local_apps.values()])
    settings_json = json.dumps(settings.to_dict())
    pending_json  = json.dumps(list((pending_approval or {}).values()))

    def _write():
        try:
            core_v1 = _k8s_core_v1()
            cm = k8s_client.V1ConfigMap(
                metadata=k8s_client.V1ObjectMeta(
                    name=_STATE_CONFIGMAP, namespace=namespace),
                data={
                    "local_apps": apps_json,
                    "settings": settings_json,
                    "pending_approval": pending_json,
                },
            )
            try:
                core_v1.create_namespaced_config_map(namespace, cm)
            except k8s_client.ApiException as e:
                if e.status == 409:
                    core_v1.patch_namespaced_config_map(_STATE_CONFIGMAP, namespace, cm)
                else:
                    raise
            _log.debug("Persisted %d local app(s), %d pending, + settings to ConfigMap",
                       len(local_apps), len(pending_approval or {}))
        except Exception as exc:
            _log.warning("Could not persist state to ConfigMap: %s", exc)

    threading.Thread(target=_write, daemon=True).start()


def load_state_configmap(namespace: str) -> dict:
    """
    Load local_apps, pending_approval, and settings from the porpulsion-state ConfigMap.
    Returns {"local_apps": [...], "pending_approval": [...], "settings": {...}} or {} on error.
    """
    import json
    import logging
    _log = logging.getLogger("porpulsion.tls")
    try:
        core_v1 = _k8s_core_v1()
        cm = core_v1.read_namespaced_config_map(_STATE_CONFIGMAP, namespace)
        result = {}
        if cm.data and "local_apps" in cm.data:
            result["local_apps"] = json.loads(cm.data["local_apps"])
        if cm.data and "settings" in cm.data:
            result["settings"] = json.loads(cm.data["settings"])
        if cm.data and "pending_approval" in cm.data:
            result["pending_approval"] = json.loads(cm.data["pending_approval"])
        _log.info("Loaded %d local app(s), %d pending, + settings from ConfigMap",
                  len(result.get("local_apps", [])),
                  len(result.get("pending_approval", [])))
        return result
    except Exception as exc:
        _log.warning("Could not load state from ConfigMap: %s", exc)
        return {}
